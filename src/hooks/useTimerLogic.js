import { useState, useEffect, useRef, useCallback } from 'react';\nimport { storage } from '../utils/storage';\nimport { analytics } from '../utils/analytics';\nimport { rankingService } from '../services/rankingService';\nimport { addMilestoneNotification, addRankingNotification, addActivityNotification } from '../services/liveFeedService';\nimport { getTimeBasedActivityRecommendation } from '../data/timeBasedActivities';\nimport { \n  ROAST_MESSAGES, \n  getRankingMessage, \n  getTimeBasedMessage, \n  getRandomRoastMessage,\n  getIntegratedMessage \n} from '../data/roastMessages';\nimport { AD_MESSAGES } from '../data/adMessages';\nimport { BUTTON_TEXTS } from '../data/buttonTexts';\n\n// 메인 타이머 및 상태 관리 훅\nexport const useTimerLogic = () => {\n  // 기본 상태들\n  const [startTime] = useState(Date.now());\n  const [elapsedTime, setElapsedTime] = useState(0);\n  const [currentMessage, setCurrentMessage] = useState(\"당신의 소중한 시간이 흘러가고 있습니다...\");\n  const [currentMessageData, setCurrentMessageData] = useState(null);\n  const [displayMessage, setDisplayMessage] = useState(\"\");\n  const [userHistory, setUserHistory] = useState({ visits: 1, patterns: {} });\n  const [buttonText, setButtonText] = useState(BUTTON_TEXTS[0]);\n  const [showAd, setShowAd] = useState(false);\n  const [adMessage, setAdMessage] = useState(AD_MESSAGES[0]);\n  const [visits, setVisits] = useState(1);\n  const [totalTimeWasted, setTotalTimeWasted] = useState(0);\n  const [adClicks, setAdClicks] = useState(0);\n  const [messageShake, setMessageShake] = useState(false);\n  const [isPageVisible, setIsPageVisible] = useState(true);\n  const [extremeMode, setExtremeMode] = useState(false);\n  const [isTyping, setIsTyping] = useState(false);\n  const [concurrentUsers, setConcurrentUsers] = useState(3);\n  const [currentUser, setCurrentUser] = useState(null);\n  const [isRankingInitialized, setIsRankingInitialized] = useState(false);\n  const [currentRank, setCurrentRank] = useState(null);\n  const [lastRankCheckTime, setLastRankCheckTime] = useState(0);\n  \n  const typingRef = useRef(null);\n\n  // 타이핑 애니메이션 함수\n  const typeMessage = useCallback((message) => {\n    if (typingRef.current) {\n      clearTimeout(typingRef.current);\n      typingRef.current = null;\n    }\n    \n    if (!message || typeof message !== 'string') {\n      console.warn('Invalid message:', message);\n      setDisplayMessage(\"오류가 발생했습니다. 다시 시도해주세요.\");\n      setIsTyping(false);\n      return;\n    }\n    \n    setIsTyping(true);\n    setDisplayMessage(\"\");\n    \n    const chars = Array.from(message);\n    let currentText = \"\";\n    let index = 0;\n    \n    const type = () => {\n      if (index < chars.length) {\n        currentText += chars[index];\n        setDisplayMessage(currentText);\n        index++;\n        typingRef.current = setTimeout(type, 30 + Math.random() * 20);\n      } else {\n        setIsTyping(false);\n      }\n    };\n    \n    type();\n  }, []);\n\n  // 현재 랭킹 확인 함수\n  const checkCurrentRanking = useCallback(async (timeInSeconds) => {\n    if (!isRankingInitialized) return;\n    \n    try {\n      const rank = await rankingService.getExpectedRank(timeInSeconds);\n      const previousRank = currentRank;\n      setCurrentRank(rank);\n      \n      if (previousRank && rank < previousRank && rank <= 10) {\n        const minutes = Math.floor(timeInSeconds / 60);\n        addRankingNotification(rank, minutes, currentUser?.anonymousName);\n        \n        if (Math.random() < 0.3) {\n          const rankingMessage = getRankingMessage(rank, timeInSeconds);\n          setCurrentMessage(rankingMessage);\n          typeMessage(rankingMessage);\n        }\n      }\n    } catch (error) {\n      console.error('랭킹 확인 실패:', error);\n    }\n  }, [isRankingInitialized, currentRank, currentUser, typeMessage]);\n\n  // 메시지 새로고침\n  const refreshMessage = useCallback(() => {\n    if (elapsedTime < 10) {\n      const newMessage = \"시간 낭비의 여정이 시작되었습니다.\";\n      setCurrentMessage(newMessage);\n      setCurrentMessageData(null);\n      typeMessage(newMessage);\n      return;\n    }\n\n    const history = {\n      visits,\n      timeSpent: elapsedTime,\n      adClicks,\n      patterns: {\n        frequentVisitor: visits >= 3,\n        longTimeUser: elapsedTime >= 1800,\n        extremeUser: extremeMode\n      }\n    };\n    setUserHistory(history);\n\n    const messageResult = getIntegratedMessage(elapsedTime, currentRank, history);\n    \n    setCurrentMessage(messageResult.message);\n    setCurrentMessageData(messageResult);\n    typeMessage(messageResult.message);\n    \n    if (Math.random() < 0.4) {\n      const randomButtonText = BUTTON_TEXTS[Math.floor(Math.random() * BUTTON_TEXTS.length)];\n      setButtonText(randomButtonText);\n    }\n    \n    setMessageShake(true);\n    setTimeout(() => setMessageShake(false), 500);\n  }, [elapsedTime, visits, adClicks, extremeMode, currentRank, typeMessage]);\n\n  // 초기화 효과들\n  useEffect(() => {\n    const visits = storage.incrementVisits();\n    const storedData = storage.getAllData();\n    \n    setVisits(visits);\n    setTotalTimeWasted(storedData.totalTimeWasted);\n    setAdClicks(storedData.adClicks);\n    \n    analytics.trackSessionStart(visits, storedData.totalTimeWasted);\n  }, []);\n\n  // Firebase 랭킹 시스템 초기화\n  useEffect(() => {\n    const initializeRanking = async () => {\n      try {\n        const user = await rankingService.initializeSession();\n        setCurrentUser(user);\n        setIsRankingInitialized(true);\n      } catch (error) {\n        console.error('Firebase 랭킹 시스템 초기화 실패:', error);\n        setIsRankingInitialized(false);\n      }\n    };\n\n    initializeRanking();\n\n    return () => {\n      if (isRankingInitialized) {\n        rankingService.endSession();\n      }\n    };\n  }, []);\n\n  // 초기 메시지 타이핑\n  useEffect(() => {\n    typeMessage(currentMessage);\n  }, []);\n\n  // 타이머 업데이트\n  useEffect(() => {\n    const interval = setInterval(() => {\n      if (isPageVisible) {\n        const now = Date.now();\n        const elapsed = Math.floor((now - startTime) / 1000);\n        setElapsedTime(elapsed);\n        \n        if (isRankingInitialized && elapsed > 0) {\n          rankingService.updateTime(elapsed);\n          \n          if (elapsed === 60 || elapsed === 180 || elapsed === 300 || elapsed === 600 || elapsed === 900 || elapsed === 1800 || elapsed === 3600) {\n            const minutes = Math.floor(elapsed / 60);\n            addMilestoneNotification(minutes, currentUser?.anonymousName);\n          }\n          \n          if (elapsed > 60 && elapsed % 30 === 0 && elapsed !== lastRankCheckTime) {\n            setLastRankCheckTime(elapsed);\n            checkCurrentRanking(elapsed);\n          }\n          \n          if (elapsed > 30 && elapsed % 30 === 0 && Math.random() < 0.3) {\n            const activityRecommendation = getTimeBasedActivityRecommendation(elapsed);\n            const activityName = activityRecommendation.activities[0] || '생산적인 일';\n            addActivityNotification(`${elapsed}초 동안 \"${activityName}\" 생각 중...`, currentUser?.anonymousName);\n          }\n        }\n        \n        if (elapsed >= 60 && !showAd) {\n          setShowAd(true);\n        }\n        \n        if (elapsed >= 300 && !extremeMode) {\n          setExtremeMode(true);\n          analytics.trackExtremeMode();\n        }\n        \n        if (elapsed > 0 && elapsed % 45 === 0) {\n          refreshMessage();\n        }\n      }\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, [startTime, isPageVisible, showAd, extremeMode, isRankingInitialized, currentUser, lastRankCheckTime, checkCurrentRanking, refreshMessage]);\n\n  // 광고 메시지 업데이트\n  useEffect(() => {\n    if (!showAd || isTyping) return;\n    \n    const currentMinute = Math.floor(elapsedTime / 60);\n    const adIndex = Math.min(currentMinute - 1, AD_MESSAGES.length - 1);\n    \n    if (adIndex >= 0 && adIndex < AD_MESSAGES.length) {\n      const newAdMessage = AD_MESSAGES[adIndex];\n      setAdMessage(newAdMessage);\n    }\n  }, [showAd, isTyping, Math.floor(elapsedTime / 60)]);\n\n  // 실시간 동시 접속자 시뮬레이션\n  useEffect(() => {\n    const updateConcurrentUsers = () => {\n      const hour = new Date().getHours();\n      let baseUsers = 3;\n      let timeWeight = 1;\n      \n      if (hour >= 9 && hour <= 12) timeWeight = 1.3;\n      else if (hour >= 14 && hour <= 18) timeWeight = 1.5;\n      else if (hour >= 19 && hour <= 23) timeWeight = 1.8;\n      else if (hour >= 0 && hour <= 2) timeWeight = 1.2;\n      else timeWeight = 0.8;\n\n      const variation = (Math.random() - 0.5) * 4;\n      const newUsers = Math.max(1, Math.min(15, Math.round(baseUsers * timeWeight + variation)));\n      setConcurrentUsers(newUsers);\n    };\n\n    updateConcurrentUsers();\n    const interval = setInterval(updateConcurrentUsers, 25000);\n    return () => clearInterval(interval);\n  }, []);\n\n  // 페이지 가시성 감지\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      const visible = !document.hidden;\n      setIsPageVisible(visible);\n      \n      if (!visible) {\n        document.title = \"돌아와요... 🥺 - 시간낭비 계산기\";\n      } else {\n        document.title = \"🕒 당신이 낭비한 시간 계산기\";\n      }\n    };\n\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);\n  }, []);\n\n  // 페이지 떠나기 방지\n  useEffect(() => {\n    const handleBeforeUnload = (e) => {\n      if (elapsedTime > 60) {\n        storage.updateTotalTimeWasted(elapsedTime);\n        \n        const message = '정말로 나가시겠어요? 이제 막 재미있어지려고 했는데...';\n        e.preventDefault();\n        e.returnValue = message;\n        return message;\n      }\n    };\n\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    return () => window.removeEventListener('beforeunload', handleBeforeUnload);\n  }, [elapsedTime]);\n\n  return {\n    // 상태들\n    startTime,\n    elapsedTime,\n    currentMessage,\n    currentMessageData,\n    displayMessage,\n    userHistory,\n    buttonText,\n    showAd,\n    adMessage,\n    visits,\n    totalTimeWasted,\n    adClicks,\n    messageShake,\n    isPageVisible,\n    extremeMode,\n    isTyping,\n    concurrentUsers,\n    currentUser,\n    isRankingInitialized,\n    currentRank,\n    \n    // 함수들\n    typeMessage,\n    refreshMessage,\n    checkCurrentRanking,\n    \n    // 세터들 (필요한 경우)\n    setCurrentMessage,\n    setCurrentMessageData,\n    setDisplayMessage,\n    setButtonText,\n    setAdMessage,\n    setAdClicks,\n    setMessageShake\n  };\n};\n