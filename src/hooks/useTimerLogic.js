import { useState, useEffect, useRef, useCallback } from 'react';\nimport { storage } from '../utils/storage';\nimport { analytics } from '../utils/analytics';\nimport { rankingService } from '../services/rankingService';\nimport { addMilestoneNotification, addRankingNotification, addActivityNotification } from '../services/liveFeedService';\nimport { getTimeBasedActivityRecommendation } from '../data/timeBasedActivities';\nimport { \n  ROAST_MESSAGES, \n  getRankingMessage, \n  getTimeBasedMessage, \n  getRandomRoastMessage,\n  getIntegratedMessage \n} from '../data/roastMessages';\nimport { AD_MESSAGES } from '../data/adMessages';\nimport { BUTTON_TEXTS } from '../data/buttonTexts';\n\n// ë©”ì¸ íƒ€ì´ë¨¸ ë° ìƒíƒœ ê´€ë¦¬ í›…\nexport const useTimerLogic = () => {\n  // ê¸°ë³¸ ìƒíƒœë“¤\n  const [startTime] = useState(Date.now());\n  const [elapsedTime, setElapsedTime] = useState(0);\n  const [currentMessage, setCurrentMessage] = useState(\"ë‹¹ì‹ ì˜ ì†Œì¤‘í•œ ì‹œê°„ì´ í˜ëŸ¬ê°€ê³  ìˆìŠµë‹ˆë‹¤...\");\n  const [currentMessageData, setCurrentMessageData] = useState(null);\n  const [displayMessage, setDisplayMessage] = useState(\"\");\n  const [userHistory, setUserHistory] = useState({ visits: 1, patterns: {} });\n  const [buttonText, setButtonText] = useState(BUTTON_TEXTS[0]);\n  const [showAd, setShowAd] = useState(false);\n  const [adMessage, setAdMessage] = useState(AD_MESSAGES[0]);\n  const [visits, setVisits] = useState(1);\n  const [totalTimeWasted, setTotalTimeWasted] = useState(0);\n  const [adClicks, setAdClicks] = useState(0);\n  const [messageShake, setMessageShake] = useState(false);\n  const [isPageVisible, setIsPageVisible] = useState(true);\n  const [extremeMode, setExtremeMode] = useState(false);\n  const [isTyping, setIsTyping] = useState(false);\n  const [concurrentUsers, setConcurrentUsers] = useState(3);\n  const [currentUser, setCurrentUser] = useState(null);\n  const [isRankingInitialized, setIsRankingInitialized] = useState(false);\n  const [currentRank, setCurrentRank] = useState(null);\n  const [lastRankCheckTime, setLastRankCheckTime] = useState(0);\n  \n  const typingRef = useRef(null);\n\n  // íƒ€ì´í•‘ ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜\n  const typeMessage = useCallback((message) => {\n    if (typingRef.current) {\n      clearTimeout(typingRef.current);\n      typingRef.current = null;\n    }\n    \n    if (!message || typeof message !== 'string') {\n      console.warn('Invalid message:', message);\n      setDisplayMessage(\"ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.\");\n      setIsTyping(false);\n      return;\n    }\n    \n    setIsTyping(true);\n    setDisplayMessage(\"\");\n    \n    const chars = Array.from(message);\n    let currentText = \"\";\n    let index = 0;\n    \n    const type = () => {\n      if (index < chars.length) {\n        currentText += chars[index];\n        setDisplayMessage(currentText);\n        index++;\n        typingRef.current = setTimeout(type, 30 + Math.random() * 20);\n      } else {\n        setIsTyping(false);\n      }\n    };\n    \n    type();\n  }, []);\n\n  // í˜„ì¬ ë­í‚¹ í™•ì¸ í•¨ìˆ˜\n  const checkCurrentRanking = useCallback(async (timeInSeconds) => {\n    if (!isRankingInitialized) return;\n    \n    try {\n      const rank = await rankingService.getExpectedRank(timeInSeconds);\n      const previousRank = currentRank;\n      setCurrentRank(rank);\n      \n      if (previousRank && rank < previousRank && rank <= 10) {\n        const minutes = Math.floor(timeInSeconds / 60);\n        addRankingNotification(rank, minutes, currentUser?.anonymousName);\n        \n        if (Math.random() < 0.3) {\n          const rankingMessage = getRankingMessage(rank, timeInSeconds);\n          setCurrentMessage(rankingMessage);\n          typeMessage(rankingMessage);\n        }\n      }\n    } catch (error) {\n      console.error('ë­í‚¹ í™•ì¸ ì‹¤íŒ¨:', error);\n    }\n  }, [isRankingInitialized, currentRank, currentUser, typeMessage]);\n\n  // ë©”ì‹œì§€ ìƒˆë¡œê³ ì¹¨\n  const refreshMessage = useCallback(() => {\n    if (elapsedTime < 10) {\n      const newMessage = \"ì‹œê°„ ë‚­ë¹„ì˜ ì—¬ì •ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.\";\n      setCurrentMessage(newMessage);\n      setCurrentMessageData(null);\n      typeMessage(newMessage);\n      return;\n    }\n\n    const history = {\n      visits,\n      timeSpent: elapsedTime,\n      adClicks,\n      patterns: {\n        frequentVisitor: visits >= 3,\n        longTimeUser: elapsedTime >= 1800,\n        extremeUser: extremeMode\n      }\n    };\n    setUserHistory(history);\n\n    const messageResult = getIntegratedMessage(elapsedTime, currentRank, history);\n    \n    setCurrentMessage(messageResult.message);\n    setCurrentMessageData(messageResult);\n    typeMessage(messageResult.message);\n    \n    if (Math.random() < 0.4) {\n      const randomButtonText = BUTTON_TEXTS[Math.floor(Math.random() * BUTTON_TEXTS.length)];\n      setButtonText(randomButtonText);\n    }\n    \n    setMessageShake(true);\n    setTimeout(() => setMessageShake(false), 500);\n  }, [elapsedTime, visits, adClicks, extremeMode, currentRank, typeMessage]);\n\n  // ì´ˆê¸°í™” íš¨ê³¼ë“¤\n  useEffect(() => {\n    const visits = storage.incrementVisits();\n    const storedData = storage.getAllData();\n    \n    setVisits(visits);\n    setTotalTimeWasted(storedData.totalTimeWasted);\n    setAdClicks(storedData.adClicks);\n    \n    analytics.trackSessionStart(visits, storedData.totalTimeWasted);\n  }, []);\n\n  // Firebase ë­í‚¹ ì‹œìŠ¤í…œ ì´ˆê¸°í™”\n  useEffect(() => {\n    const initializeRanking = async () => {\n      try {\n        const user = await rankingService.initializeSession();\n        setCurrentUser(user);\n        setIsRankingInitialized(true);\n      } catch (error) {\n        console.error('Firebase ë­í‚¹ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);\n        setIsRankingInitialized(false);\n      }\n    };\n\n    initializeRanking();\n\n    return () => {\n      if (isRankingInitialized) {\n        rankingService.endSession();\n      }\n    };\n  }, []);\n\n  // ì´ˆê¸° ë©”ì‹œì§€ íƒ€ì´í•‘\n  useEffect(() => {\n    typeMessage(currentMessage);\n  }, []);\n\n  // íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸\n  useEffect(() => {\n    const interval = setInterval(() => {\n      if (isPageVisible) {\n        const now = Date.now();\n        const elapsed = Math.floor((now - startTime) / 1000);\n        setElapsedTime(elapsed);\n        \n        if (isRankingInitialized && elapsed > 0) {\n          rankingService.updateTime(elapsed);\n          \n          if (elapsed === 60 || elapsed === 180 || elapsed === 300 || elapsed === 600 || elapsed === 900 || elapsed === 1800 || elapsed === 3600) {\n            const minutes = Math.floor(elapsed / 60);\n            addMilestoneNotification(minutes, currentUser?.anonymousName);\n          }\n          \n          if (elapsed > 60 && elapsed % 30 === 0 && elapsed !== lastRankCheckTime) {\n            setLastRankCheckTime(elapsed);\n            checkCurrentRanking(elapsed);\n          }\n          \n          if (elapsed > 30 && elapsed % 30 === 0 && Math.random() < 0.3) {\n            const activityRecommendation = getTimeBasedActivityRecommendation(elapsed);\n            const activityName = activityRecommendation.activities[0] || 'ìƒì‚°ì ì¸ ì¼';\n            addActivityNotification(`${elapsed}ì´ˆ ë™ì•ˆ \"${activityName}\" ìƒê° ì¤‘...`, currentUser?.anonymousName);\n          }\n        }\n        \n        if (elapsed >= 60 && !showAd) {\n          setShowAd(true);\n        }\n        \n        if (elapsed >= 300 && !extremeMode) {\n          setExtremeMode(true);\n          analytics.trackExtremeMode();\n        }\n        \n        if (elapsed > 0 && elapsed % 45 === 0) {\n          refreshMessage();\n        }\n      }\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, [startTime, isPageVisible, showAd, extremeMode, isRankingInitialized, currentUser, lastRankCheckTime, checkCurrentRanking, refreshMessage]);\n\n  // ê´‘ê³  ë©”ì‹œì§€ ì—…ë°ì´íŠ¸\n  useEffect(() => {\n    if (!showAd || isTyping) return;\n    \n    const currentMinute = Math.floor(elapsedTime / 60);\n    const adIndex = Math.min(currentMinute - 1, AD_MESSAGES.length - 1);\n    \n    if (adIndex >= 0 && adIndex < AD_MESSAGES.length) {\n      const newAdMessage = AD_MESSAGES[adIndex];\n      setAdMessage(newAdMessage);\n    }\n  }, [showAd, isTyping, Math.floor(elapsedTime / 60)]);\n\n  // ì‹¤ì‹œê°„ ë™ì‹œ ì ‘ì†ì ì‹œë®¬ë ˆì´ì…˜\n  useEffect(() => {\n    const updateConcurrentUsers = () => {\n      const hour = new Date().getHours();\n      let baseUsers = 3;\n      let timeWeight = 1;\n      \n      if (hour >= 9 && hour <= 12) timeWeight = 1.3;\n      else if (hour >= 14 && hour <= 18) timeWeight = 1.5;\n      else if (hour >= 19 && hour <= 23) timeWeight = 1.8;\n      else if (hour >= 0 && hour <= 2) timeWeight = 1.2;\n      else timeWeight = 0.8;\n\n      const variation = (Math.random() - 0.5) * 4;\n      const newUsers = Math.max(1, Math.min(15, Math.round(baseUsers * timeWeight + variation)));\n      setConcurrentUsers(newUsers);\n    };\n\n    updateConcurrentUsers();\n    const interval = setInterval(updateConcurrentUsers, 25000);\n    return () => clearInterval(interval);\n  }, []);\n\n  // í˜ì´ì§€ ê°€ì‹œì„± ê°ì§€\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      const visible = !document.hidden;\n      setIsPageVisible(visible);\n      \n      if (!visible) {\n        document.title = \"ëŒì•„ì™€ìš”... ğŸ¥º - ì‹œê°„ë‚­ë¹„ ê³„ì‚°ê¸°\";\n      } else {\n        document.title = \"ğŸ•’ ë‹¹ì‹ ì´ ë‚­ë¹„í•œ ì‹œê°„ ê³„ì‚°ê¸°\";\n      }\n    };\n\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);\n  }, []);\n\n  // í˜ì´ì§€ ë– ë‚˜ê¸° ë°©ì§€\n  useEffect(() => {\n    const handleBeforeUnload = (e) => {\n      if (elapsedTime > 60) {\n        storage.updateTotalTimeWasted(elapsedTime);\n        \n        const message = 'ì •ë§ë¡œ ë‚˜ê°€ì‹œê² ì–´ìš”? ì´ì œ ë§‰ ì¬ë¯¸ìˆì–´ì§€ë ¤ê³  í–ˆëŠ”ë°...';\n        e.preventDefault();\n        e.returnValue = message;\n        return message;\n      }\n    };\n\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    return () => window.removeEventListener('beforeunload', handleBeforeUnload);\n  }, [elapsedTime]);\n\n  return {\n    // ìƒíƒœë“¤\n    startTime,\n    elapsedTime,\n    currentMessage,\n    currentMessageData,\n    displayMessage,\n    userHistory,\n    buttonText,\n    showAd,\n    adMessage,\n    visits,\n    totalTimeWasted,\n    adClicks,\n    messageShake,\n    isPageVisible,\n    extremeMode,\n    isTyping,\n    concurrentUsers,\n    currentUser,\n    isRankingInitialized,\n    currentRank,\n    \n    // í•¨ìˆ˜ë“¤\n    typeMessage,\n    refreshMessage,\n    checkCurrentRanking,\n    \n    // ì„¸í„°ë“¤ (í•„ìš”í•œ ê²½ìš°)\n    setCurrentMessage,\n    setCurrentMessageData,\n    setDisplayMessage,\n    setButtonText,\n    setAdMessage,\n    setAdClicks,\n    setMessageShake\n  };\n};\n